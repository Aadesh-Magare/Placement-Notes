according to chomsky hierarchy grammers are divided into four types:

// Type 0 : Unrestricted grammer 
    type 0 grammers include all formal grammers.
    type 0 grammer language are recognized by turing machine and known as recursively enumerable language.



Type of grammer                Type of language                                 Machine 
(Generator of language)                                                   (Acceptor of lang)

RG                          Regular language (a^n n >= 1)                       => FA
CFG                         Context free language (a^nb^n n >= 1)               => PDA
CSG                         Context sensitive language (a^nb^nc^n n >= 1)       => LBA
UG                          Recursively enumerable set (a^p p = prime number)   => TM



// Regular Language :
    
    Representor : Regular expressions
    Acceptor : Finite automata (FA)
    Generator : Regular Grammar (RLG and LLG : Right / Left Linear Grammar)

    If a language is accepted by FA then its regular language and we can represent it using regular expressions.

    You can convert FA to RE and vice versa.

    RE can be converted to FA by simply observation.
    
    // FA to RE :
        1. make sure initial state does not have any incoming edges : if it has create a new initial state and a epsilon transition from this new state to earlier initial state

        2. make sure final state does not have any outgoing edges and there is only one final state : it its not the case, create a new final state and a epsilon transition from current final state to the new state.

        3. eliminate other states between initial and final states such that there is no change in path and transitions.


    a finite language is always regular language.
    a infinite language may be regular but not always : if the language strings have some pattern like (ab, abab, ababab...) then a FA with loop can accept that language and hence it can be a regular language.

    // Pumping lenma : if an infinite language does not have any repeating pattern then it's not regular language. if such pattern exists then it may be regular.

    so failing Pumping lenma guarantees that the language is not regular but passing the lenma does not necessarily mean its regular language. hence Pumping lenma is negativity test.

    these patterns mostly form an AP (arithmatic progression) if no such pattern can be found then we can say its not regular language.

    e.g. a^n where n is even 
        a^n where n is odd
        both of these forms AP with common difference of 2 between terms so we can generate these with a loop, hence its regular language.

        a^n where n is prime
        a^n^2    where n >= 1 
        a^2^n where n >= 1 all 3 of these are not regular, cause the terms don't form an AP hence there is no suitable pattern.

    a language which needs infinite memory is not regular
    e.g. a^nb^n where n > 1 here first we need to count no of a and then compare with no of b. but no of a can be infinite we can't count them all with finite memory hence its not regular language.

    a^nb^m where n, m > 1 is a regular language because we don't need to count no of a or b. both are independent we can have any no of a followed by any no of b. hence its possible to construct FA for it.


// Regular Grammar :
    tuple V, T, P, S 
        V : set of all vertices
        T : set of all terminals
        P : set of all productions
        S : start symbol

        Derivation : getting the string from the grammer 
        if you start replacing left most vertex its called left most Derivation and for right most vertex its called right most Derivation.

        intermediate string got in the Derivation are called sentential forms or sequential forms.
        



