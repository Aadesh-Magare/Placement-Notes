// Regular Language :
    
    Representor : Regular expressions
    Acceptor : Finite automata (FA)
    Generator : Regular Grammar (RLG and LLG : Right / Left Linear Grammar)

    If a language is accepted by FA then its regular language and we can represent it using regular expressions.

    You can convert FA to RE and vice versa.

    RE can be converted to FA by simply observation.
    
    // FA to RE :
        1. make sure initial state does not have any incoming edges : if it has create a new initial state and a epsilon transition from this new state to earlier initial state

        2. make sure final state does not have any outgoing edges and there is only one final state : it its not the case, create a new final state and a epsilon transition from current final state to the new state.

        3. eliminate other states between initial and final states such that there is no change in path and transitions.


    a finite language is always regular language.
    a infinite language may be regular but not always : if the language strings have some pattern like (ab, abab, ababab...) then a FA with loop can accept that language and hence it can be a regular language.

    // Pumping lemma : if an infinite language does not have any repeating pattern then it's not regular language. if such pattern exists then it may be regular.

    so failing Pumping lemma guarantees that the language is not regular but passing the lemma does not necessarily mean its regular language. hence Pumping lemma is negativity test.

    these patterns mostly form an AP (arithmatic progression) if no such pattern can be found then we can say its not regular language.

    e.g. a^n where n is even 
        a^n where n is odd
        both of these forms AP with common difference of 2 between terms so we can generate these with a loop, hence its regular language.

        a^n where n is prime
        a^n^2    where n >= 1 
        a^2^n where n >= 1 all 3 of these are not regular, cause the terms don't form an AP hence there is no suitable pattern.

    a language which needs infinite memory is not regular
    e.g. a^nb^n where n > 1 here first we need to count no of a and then compare with no of b. but no of a can be infinite we can't count them all with finite memory hence its not regular language.

    a^nb^m where n, m > 1 is a regular language because we don't need to count no of a or b. both are independent we can have any no of a followed by any no of b. hence its possible to construct FA for it.


// Regular Grammar :
    tuple V, T, P, S 
        V : set of all vertices
        T : set of all terminals
        P : set of all productions
        S : start symbol

        Derivation : getting the string from the grammar 
        if you start replacing left most vertex its called left most Derivation and for right most vertex its called right most Derivation.

        intermediate string got in the Derivation are called sentential forms or sequential forms.


// According to chomsky hierarchy grammars are divided into four types:
    Type 3 : RG
    Type 2 : CFG
    Type 1 : CSG
    Type 0 : UG

// Type 3 : Regular grammar (RG)

    Language generated by it is regular language, which can be represented by regular expressions and accepted by FA. (RG, RE, RL, FA are same in power and interconvertible)

    when the grammar has all productions of RLG or LLG type and not mix of them.
    RLG : A -> aB | b where A,B are vertices and a, b are terminals.
    LLG : A -> Ba | b where A,B are vertices and a, b are terminals.

    if you reverse a RLG to make it LLG the language generated by them does not remain same it gets reversed too. so converting RLG to LLG does not envolve simply reversing the grammar.

    // Conversions:
        FA => RLG : can convert by just observation.
        FA => LLG : reverse FA, convert to RLG, reverse RLG to get LLG.
        RLG => FA : can convert by just observation.
        LLG => FA : reverse LLG to get RLG, convert to FA, reverse FA.

// Type 2 : Context-free grammar (CFG)

    Language generated by it is context free language, which can be accepted by PDA.

    It can be classified into different types such as :
        1. Ambiguous or Unambiguous :
            If there exists more than one derivation tree for a string then the grammar is Ambiguous else Unambiguous.
            Language generated by Ambiguous grammar may or may not be Ambiguous.
        2. Deterministic or Non-Deterministic.
            Deterministic is always Ambiguous.
        3. Left-Recursive or Right-Recursive.

    It's called Context-free because all productions are independent of the context. i.e. in the below production you can replace A with alpha anywhere without worrying about what is before or after A, it does not depend on the context.

    when the grammar has productions of the form :
        A -> alpha where A is vertex and alpha can be vertex or terminal.
        Left side of production can have only one variable.

    to check whether given string is contained by grammar or not we have to use some algorithm to check.
    for efficiency of algorithm we have to remove epsilon productions and unit productions from grammar. not all epsilon productions can be removed hence we should remove all those which can be removed.

    // Elimination of e-productions :
        Nullable variable : a variable that can generate epsilon directly or indirectly.
        e.g. A -> e
        the productions where Nullable variable appear on right side write them again without the Nullable variable.
            S -> aSb | aAb
            rewrite as : S -> aSb | aAb | ab    (without A variable)

    // Elimination of unit-productions :
        Unit productions : of the form A -> B. which neither increase no of variables nor introduce terminal.

        Elimination should not have any affect on the strings that can be generated by the grammar, so add terminal productions to rectify the affect of this elimination.

    // Elimination of use-less symbol :
        symbols that are unreachable from the start symbol.
        a usefull symbol is one which can derive some terminal in final string.

    Union, concatenation and kleen closure of CF Languages is also CF language.
    but intersection and complement of CF Languages need not be CF language always.

// Type 1 : Context-sensitive grammar (CSG)
    Languages generated by it are recognized by Linear Bound Automata (LBA) and known as context-sensitive language.
    
    The grammar has productions of the form :
        alpha -> beta 
        where alpha, beta can be variable or terminal
        count of symbols in alpha should be less than or equal to that in beta.

// Type 0 : Unrestricted grammar (UG)
    It includes all formal grammars.
    Languages generated by it are recognized by turing machine and known as recursively enumerable language.

    The grammar has productions of the form :
        alpha -> beta 
        where alpha is combination of variables and terminals with at least one variable.
        beta is combination of variables and terminals.

// Summary :

Type of grammar                Type of language                                 Machine 
(Generator of language)                                                   (Acceptor of lang)

RG (T-3)                    Regular language (a^n n >= 1)                       => FA
CFG (T-2)                   Context free language (a^nb^n n >= 1)               => PDA
CSG (T-1)                   Context sensitive language (a^nb^nc^n n >= 1)       => LBA
UG (T-0)                    Recursively enumerable set (a^p p = prime number)   => TM
