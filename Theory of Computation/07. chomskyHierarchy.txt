// Regular Language :
    
    Representor : Regular expressions
    Acceptor : Finite automata (FA)
    Generator : Regular Grammar (RLG and LLG : Right / Left Linear Grammar)

    If a language is accepted by FA then its regular language and we can represent it using regular expressions.

    regular language is closed under union, intersection, concatenation, complement and kleen closure as well, hence if two languages are regular these operations on them will also produce regular language only.

    You can convert FA to RE and vice versa.

    RE can be converted to FA by simply observation.
    
    // FA to RE :
        1. make sure initial state does not have any incoming edges : if it has create a new initial state and a epsilon transition from this new state to earlier initial state

        2. make sure final state does not have any outgoing edges and there is only one final state : it its not the case, create a new final state and a epsilon transition from current final state to the new state.

        3. eliminate other states between initial and final states such that there is no change in path and transitions.


    a finite language is always regular language.
    a infinite language may be regular but not always : if the language strings have some pattern like (ab, abab, ababab...) then a FA with loop can accept that language and hence it can be a regular language.

    // Pumping lemma : if an infinite language does not have any repeating pattern then it's not regular language. if such pattern exists then it may be regular.

    so failing Pumping lemma guarantees that the language is not regular but passing the lemma does not necessarily mean its regular language. hence Pumping lemma is negativity test.

    these patterns mostly form an AP (arithmetic progression) if no such pattern can be found then we can say its not regular language.

    e.g. a^n where n is even 
        a^n where n is odd
        both of these forms AP with common difference of 2 between terms so we can generate these with a loop, hence its regular language.

        a^n where n is prime
        a^n^2    where n >= 1 
        a^2^n where n >= 1 all 3 of these are not regular, cause the terms don't form an AP hence there is no suitable pattern.

    a language which needs infinite memory is not regular
    e.g. a^nb^n where n > 1 here first we need to count no of a and then compare with no of b. but no of a can be infinite we can't count them all with finite memory hence its not regular language.

    a^nb^m where n, m > 1 is a regular language because we don't need to count no of a or b. both are independent we can have any no of a followed by any no of b. hence its possible to construct FA for it.


// Regular Grammar :
    tuple V, T, P, S 
        V : set of all vertices
        T : set of all terminals
        P : set of all productions
        S : start symbol

        Derivation : getting the string from the grammar 
        if you start replacing left most vertex its called left most Derivation and for right most vertex its called right most Derivation.

        intermediate string got in the Derivation are called sentential forms or sequential forms.


// According to chomsky hierarchy grammars are divided into four types:
    Type 3 : RG
    Type 2 : CFG
    Type 1 : CSG
    Type 0 : UG

// Type 3 : Regular grammar (RG)

    Language generated by it is regular language, which can be represented by regular expressions and accepted by FA. (RG, RE, RL, FA are same in power and inter convertible)

    when the grammar has all productions of RLG or LLG type and not mix of them.
    RLG : A -> aB | b where A,B are vertices and a, b are terminals.
    LLG : A -> Ba | b where A,B are vertices and a, b are terminals.

    if you reverse a RLG to make it LLG the language generated by them does not remain same it gets reversed too. so converting RLG to LLG does not involve simply reversing the grammar.

    // Conversions:
        FA => RLG : can convert by just observation.
        FA => LLG : reverse FA, convert to RLG, reverse RLG to get LLG.
        RLG => FA : can convert by just observation.
        LLG => FA : reverse LLG to get RLG, convert to FA, reverse FA.

// Type 2 : Context-free grammar (CFG)

    Language generated by it is context free language, which can be accepted by PDA.

    It can be classified into different types such as :
        1. Ambiguous or Unambiguous :
            If there exists more than one derivation tree for a string then the grammar is Ambiguous else Unambiguous.
            Language generated by Ambiguous grammar may or may not be Ambiguous. A language is Ambiguous only when there is no Unambiguous grammar possible for it.
        2. Deterministic or Non-Deterministic.
            Deterministic is always Unambiguous.
        3. Left-Recursive or Right-Recursive.

    It's called Context-free because all productions are independent of the context. i.e. in the below production you can replace A with alpha anywhere without worrying about what is before or after A, it does not depend on the context.

    when the grammar has productions of the form :
        A -> alpha where A is vertex and alpha can be vertex or terminal.
        Left side of production can have only one variable.

    to check whether given string is contained by grammar or not we have to use some algorithm to check.
    for efficiency of algorithm we have to remove epsilon productions and unit productions from grammar. not all epsilon productions can be removed hence we should remove all those which can be removed.

    // Elimination of e-productions :
        Nullable variable : a variable that can generate epsilon directly or indirectly.
        e.g. A -> e
        the productions where Nullable variable appear on right side write them again without the Nullable variable.
            S -> aSb | aAb
            rewrite as : S -> aSb | aAb | ab    (without A variable)

    // Elimination of unit-productions :
        Unit productions : of the form A -> B. which neither increase no of variables nor introduce terminal.

        Elimination should not have any affect on the strings that can be generated by the grammar, so add terminal productions to rectify the affect of this elimination.

    // Elimination of use-less symbol :
        symbols that are unreachable from the start symbol.
        a useful symbol is one which can derive some terminal in final string.

    CF language is closed under Union, concatenation and kleen closure. hence union, concatenation and kleen closure of CF Languages is also CF language.
    but intersection and complement of CF Languages need not be CF language always.

// Type 1 : Context-sensitive grammar (CSG)
    Languages generated by it are recognized by Linear Bound Automata (LBA) and known as context-sensitive language.
    
    The grammar has productions of the form :
        alpha -> beta 
        where alpha, beta can be variable or terminal
        count of symbols in alpha should be less than or equal to that in beta.

    context-sensitive language is closed under Union, intersection, concatenation, complement and kleen closure.

// Type 0 : Unrestricted grammar (UG)
    It includes all formal grammars.
    Languages generated by it are recognized by turing machine and known as recursively enumerable language (RE)

    Since the language is accepted by turing machine, it will enter final state for strings that are accepted and may or may not enter rejecting state for strings that are not accepted. TM can loop forever for strings that are not part of language. The language is also called as turing recognizable language.

    Deterministic and Non-Deterministic TM have same power and are inter convertible.

    // Recursive Language (REC):
        It's subset of recursively enumerable language.
        It's also called as turing-decidable language. TM will enter final state for strings that are accepted, and rejecting state for strings that are not accepted. It won't loop forever.

        complement of turing-recognizable language need not be a turing-recognizable language. while complement of turing-decidable language is a turing-decidable language.

        REC is closed under union, intersection, concatenation, complement and kleen closure as well.

        RE language is closed under union, intersection, concatenation and kleen closure.
        
    The grammar has productions of the form :
        alpha -> beta 
        where alpha is combination of variables and terminals with at least one variable.
        beta is combination of variables and terminals.

    // Decidable language :
        a language is decidable if it is Recursive language. all Recursive languages are decidable and vice versa.
    
    // Partially Decidable language :
        a language is Partially decidable if it is recursively enumerable (RE) language.
    
    // Undecidable language:
        if a language is not decidable then it is Undecidable language. It may be Partially decidable or not.
        If a language is not even Partially decidable then there does not exist TM for that language.
        
// Summary :

Type of grammar                Type of language                                 Machine 
(Generator of language)                                                   (Acceptor of lang)

RG (T-3)                    Regular language (a^n n >= 1)                       => FA
CFG (T-2)                   Context free language (a^nb^n n >= 1)               => PDA
CSG (T-1)                   Context sensitive language (a^nb^nc^n n >= 1)       => LBA
UG (T-0)                    Recursively enumerable set (a^p p = prime number)   => TM
