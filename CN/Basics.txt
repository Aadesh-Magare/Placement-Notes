Internet standards are developed by Internet engineering task force, their standard documents are called requests fro comments.

Repeater : operates at physical layer. if signal becomes weak, regenerates it.

Internet can be seen as infrastructure that provides services to application. Internet API are used by applications to send data to other hosts over the network.

protocol defines the set of rules or format of communication.

Physical medium : which actually carry signals
	guided media : cables
	unguided media : wireless, satelites.

Packet switching : source breaks the file to be sent into chunks known as  packets. these travel through communication links and packet switches. (router or link-layer switches).

Baseband vs BroadBand :
	baseband : entire bandwidth is consumed by single signal.
	BroadBand : signals are sent on multiple frequencies.
Transmission :
	store and forward, the packet switches may store packets till it recieves all of them and then forward them.
	if the network is conjusted, packets are saved in output buffer and this call queue delay due to buffer.if buffer is full, incoming packets are lost.

	circuit switching networks:
	resources needed along the path are reserved while in packet switched network they aren't reserved. telephones use circuit switching, before th e call is made circuit is reserved. due to this guranteed constat rate is achieved for transfers.

Transmission delay : delay at router to push packet onto network, that depends on size of packet and transmission rate of medium.

Propagation delay : time required for packet to travel through medium. that depends on the length of path.

nodal delay : processing delay + queueing delay +transimssion delay + propagation delay

Encapsulation :
	all nodes dont use all of OSI layers. source and destination use all 7 ,layers, link-layer switches use only the bottom two layers, while routers use bottom 3 layers.

	an application-layer message is passed to the transport layer.the transport layer takes the message and appends additional information (transport-layer header information)that will be used by the receiver-side transport layer. The application-layer message and the transport-layer header information together constitute the transport-layer segment. 
	The transport-layer segment thus encapsulates the application-layer message. The added information might include information allowing the receiver-side transport layer to deliver the message up to the appro-priate application, and error-detection bits that allow the receiver to determine whether bits in the message have been changed in route. The transport layer then passes the segment to the network layer, which adds network-layer header information such as source and destination end system addresses, creating a network-layer datagram. The datagram is then passed to the link layer, which will add its own link-layer header information and create a link-layer frame. Thus, we see that at each layer, a packet has two types of fields: header fields and a payload field. The payload is typically a packet from the layer above.

DOS : denial of service, send too many requests to server and block it, or conjust the network with too many packets.

DDOS : destributed dos. lot of machines at the same time try to conjust the network or flood the medium.

packet sniffer : its passive component that doesnt change anything but keep copy of every packet. 

IP spoofing : ability to inject packets into network with false source address. so anyone can masquerade as legit source.

intenet was invented with philosophy of mutually trusting users attached to transperent network.


//Socket :
	its an interface between application layer and trasnport layer.
	to identify destination process we use ip address of host and port no (for process identification)

//transport should provides:
	Reliable data transfer :
		guarantee that there will be no data loss.
	Throughput: 
		Bandwidth sensitive applications require that at least some throughput should be guaranteed (say x bit/sec) by transport layer.
	Timing : 
		max time to deliver packets.
	Security : 
		data can be encrypted before sending.

//Today's internet cant provide throughput and Timing guarantees.

//TCP :
	connection oriented and Reliable service.
	it makes sure all data in transfered to destination with no corruption and in-sequence
	also includd a congestion control mechanism.

	it uses three way handshaking.

//SSL : secure socket layer 
	its an enhancement to TCP. implemented as application layer. if one wants to use ssl he must include its code. ssl provide API similar to standard TCP. application writes data on ssl socket and it does encryption.

//UDP :
	connectionless, unreliable service.
	messages may get lost, and may arrive out of order.
	no congestion control mechanism.

	client open a socket send msg through socket each packet has destination address and port no and reads data back from the socket (sent by server).  server reads data from socket and writes to it.	
//HTTP :
	its application layer protocol. it defines how web clients request pages from server and how server transfer pages to clients. it uses TCP as underlying protocol.
	client http makes request to its socket and gets data from socket. server http recieve request from socket and writes data to socket. all internal transfer and reliability concerns are handled by TCP.

	its said to be stateless protocol, cause server doenst remember what it just did. if client again requests the same thing server will send it again, not knowing that it just sent it.

	there are two types of messages request and response.

//URL encoding : 
	url should have ASCII characters only so that it can be sent over network, but if url has non ASCII characters then they are encoded.  % followed by two hex digits are used for encoding.


//Persistent non-persistent connection:
	if a new tcp connection is made for each request then its non-persistent connection else its Persistent connection, since it maintains the connection.

//Round trip time : time for packet to travel from clinet to server and back to client.

//Cookie :
	when you visit a site for first time, server create unique id for you and saves it in database. it return the unique value to you as http response under cookie header. your browse saves that value in cookie file corresponding to that website. then all of packets for that site will contain Cookie no, from that no in packet server can identifiy you.

//Web cache (Proxy server) :
	it keeps copy of recently requested objects.a brower is configured so that all request go through Proxy server. it acts as destination and checks if it has that content if not it send request to original destination. it acts as both client and server.

	//conditional GET :	
		to ensure proxy server has updated copy of object http support conditional get request i.e. actual data is sent by server only if its been modified since the last time it was accessed.

//FTP:
	uses two parallel connections while HTTP uses only one.
	one is control connection and other is data connection.
	http uses same connection for data and control information (id, password, commands) so its called in-band while FTP uses different connection so its called out-of-band sending.
	SMTP is also in-band.
	control connection is only one but it uses one connection for each file. i.e. data connection is not Persistent.
	HTTP is stateless but for FTP server must maintain state of each client to know its current directory.


//SMTP:
	simple mail transfer protocol : it transfer the mail from senders mail server to reciepients mail server.
	senders use user-agent to send mail which sends mail to his mail server. it uses client side SMTP protocol to send mail from senders pc to senders mail server.the mail server transfers it to reciepients mail server using server side SMTP, reciever uses user-agent to fetch mail from server to his pc by using mail access protocol.

	it uses reliabile TCP protocol.
	it doesnt use intermediate mail servers i.e. direct tcp connection is made between senders and reciepient. mail is not stored on intermediate server.
	http is pull ptotocol : reciepient creates connection, smtp is push senders create.
	smtp needs everything in 7bit ascii data so encoding may be required its not the case with http

	mail access protocol : POP3 (Post office protocol), IMAP (Internet mail access protocol) and http. these protocols are used to transfer mail from mail server to local pc.

	POP3 : uses TCP connection with mail server. it works in three phases authorization, transaction and update.
	does not allow creating remote folders and orgnizing mails into them.

	IMAP : mails are associated with folders, users can create folders and move mails on server. IMAP maintains this state information across sessions.

	HTTP : using browser access mails. data sending and recieving occurs through http. further transfers occurs through smtp.

	DNS : there can be serveral ip address for one domain name. dns servers contains all of them and send them in shuffled order for each request for load balancing on ip.	
	it uses UDP connection.

	//DNS is destributed and not centralised because :
		it uses UDP protocol.
		to avoid single point of failure.
		trafic overload
		manage physical distance
		difficult to manage centralised.

		root dns servers : 13 distributed  across globe.
		top level domain servers : responsible for top level domains like com, net, org and country wise domains in, uk, au 
		authorative servers : specific to orgnization like amazon.

		local dns server (default name server) : client request to local dns in recursive manner (i.e. local dns makes further request to root, tld and authorative servers and return final result)

		the request from client to local server is recursive while further are iterative

		DNS cache : dns server cache the mapping recieved for further use, further requests for the same name are processed from the cache. since the mappings are not permanent the cache is deleted after some time (e.g. two days)

		//some sites work with www while other don't ?
			its because dns has entries for www.sitename.com and sitename.com, the www is just convention you can put anything there, like afafa.sitename.com and add entry in dns for this then site will work.
//Layers in OSI model : open systems interconnection.
	1. physical layer
	2. data link layer
	3. Network layer
	4. transport layer
	5. session layer
	6. presentaton layer
	7. application layer

//Layers in TCP/IP model :
	1. Network Access Layer (1 & 2)
	2. Internet layer (3)
	3. transport layer (4)
	4. application layer (5,6, & 7)

//Transport Layer : converts upper layer data into segments.
	two transport layer protocols are available UDP and TCP.
	responsibility of UDP or TCP is to extend IP's delivery service between two nodes to between two processes.

//Network layer : provides IP protocol, it has unreliable service.
	multiplexing : it takes data from various sockets encapsulate it into transport layer segment, adds some headers and sends to network layer.

	demultiplexing : it takes segment from network layer and decapsulate data and send to reciepent socket.

	TCP and UDP headers have fields for source port and destination port. these are 16 bit no. 

	0 to 1023 are well-known ports reserved for famous services.

//Reliable Data transfer :
	ARQ protocol : automatic repeat request. it needs error detection, reciever feedback and retransmission facility.

	stop and wait protocol : sender sends one packet and waits till it recieves ACK or NAK from other side, on NAK it resends packet and on ACK it takes new packet to send.

	sender keeps a field called sequence no in the packet for reciver to identify new packets from the retransmitted packets.

	to guard against packet loss, server may resend packet after some time if ACK is not recieved. the time should be more than round trip time.

	stop and wait does not utilize the bandwidth since it keep waiting. so pipelining protocol is introduced.
		two protocols for this type are :
			//Go back N :
				its also called sliding window protocol. N is window size, in window of N packets some are transmitted but not acknowledged while some are still not transmitted.

				on reciept of acknowledged of a packet it assumes that all packets prior to it are also recieved by reciever its called cumulative ack.

				on timeout sender sends all previously sent (before this timed out packet) but not acknowledged packets.

				reciever discards all out of order packets and sends ACK for most recent in order packet.

			//Selective Repeat :
				avoid retransmition of all packets and retransmit those only that are required.

				on reciept of acknowledment of packet only that packet is marked as acknowled. and not the ones before it.

				on timeout only that packet is retransmitted and not the ones before it.

				reciever sends ack for packets even if they are out of order. and it sends a chunk of in order packets to upper layer.
	//TCP :
		connection oriented protocol, but the its not circuit switched network. the connection is maintained by end systems only i.e. source and destination. 

		no multicasting with TCP, its only for point to point communication.

		connection is established by three way handshake cause three packets are transferred for connection establishment.

		it creates segments whose maximum size depends on underlying MTU (maximum transmission unit supported by physical layer)

		the header for TCP contains source and destination port no , checksum field, sequence no , ack no.

		the sequence no in TCP is not segment no but it depends on the bytes transferred and size of each segment. 

		ACk no in TCP is the next sequence no its expecting. so if destination recieved sequence no 8, it will send ACK 9 since it now needs sequence no 9.

		Piggybacked : the ack for reciept of one packet may be sent with another packet carrying data so the acknowledgement is said to be Piggybacked with data.

		selective acknowledgement :
		out of order segments are not individually ack by reciever., it waits till it fills in the gap in them before sending the cumulative ack. 
		out of order segments are ack selectively and not blindly .

		flow control : speed matching service.
		sender should not full the buffers of reciever.
		sender may be told to slow down due to congestion control.
		cumulative acknowledgement avoids retransmission of data.

		TCP flow control : TCP provids flow control using recieve window. in every segment reciever sends how much space it has remaining in the recieve window, accordingly sender slows down.

		//Three way handshake :
			client to server : SYN segment, with syn bit set to 1 and random seq no.
			server to client : SYNACK segment, with syn bit set to 1, ack no as seq no + 1 and a random seq no. this is connection granted segment and this is time when server should allocate resource to the client but doing so makes it vulnerable to DOS attack, hence thats done after third step.
			client to server : allcoates buffers and send ack for connection grantd segment with ack no as seq no from server + 1. SYN bit is set to 0. this segment may carry data also.


		to terminate connection FIN segment is sent for which other party sends ACK, upon recieving the ACK, terminator sends its ACK and connection is closed.

		//congestion control : network layer does not provide it so transport layer must ensure it through end to end control.
		segment loss (timeout or tripple ack) or increase in round trip delay can mean congestion has occured.	
		network assisted congestion control : routers tell end systems about congestion in medium by some messges
		router may send a packet to sender directy stating congestion (choke packet) or modify the packet going from sender to reciever so that reciever gets to know about congestion.

		TCP congestion control : (additive increase multiplicative decrease)
			slow start : the rate is doubled on each ack recieved, till there is loss due to  time out that means congestion.
			once its detected slow start phase is restarted, rate is brought down to lowest and threshold is set to half of when congestion occured.
			now second time when we cross threshold slow start phase ends.
			congestion avoidance : 
				the rate is increased by one instead of doubling it. when congestion occurs in this state same algorithm is followed. i.e. rate is brought down to lowest and threshold is set to half of when congestion occured.
				when tripple ACK are there instead of timeout rate is brought down to half of currnet value instead of lowest. since tripple ACK does not mean sure congestion while timeout means congestion.

//Network Layer :
	
	virtual circuit network : connection service at network layer. connection is implemented by end systems as well as routers along path.
	datagram network : connectionless service at network layer.

	network layer packet is called datagram.

	//VC :
		it consist of path between source and destination, along path each link has some VC no. each router has forwarding table with entries for incoming VC no and outgoing VC no. a packet belonging to VC will carry a VC no in its header, router changes the VC no in packet to VC no of link after forwarding it on some link.
		whenever a new VC is established across router its entry is added into router.
		routers are involved in circuit as opposed to TCP circuit where only end systems know about the circuit.

	//Datagram Network :
		sends a packet with destination address without creating circuit.
	
	//Source route is sequence of ip addresses that datagram must follow.

	//IPv4 :
		TTL : time to leave field is present in ip datagram header. its value is decreamented by each router before forwarding. when it reaches to 0 packet is dropped. this is to avoid circulation of packet forever.

		the header also contains a filed protocol which tells to which upper layer the packet should be given to i.e. to TCP or UDP.

		source and destination address in header contains ultimate source and destination for packet.

		when MTU of link layer is smaller than the datagram size, it needs to be fragmented. destination host then reasselbles the fragments into original datagram. routers dont reasselbles the fragments they just forward it.

		each datagram has unique identification no. when its fragmented, its fragments also have same identification no, from this destination can determine that these are fragments of same datagram. to know their sequence, offset is provided which represets the position of fragment in original datagram. to indicate last fragment special bit is used.

		subnet mask : 123.1.3.0/24 means left most 24 bits define the subnet, while the remaining 8 bits can be used to identify individual hosts in subnet. generalization of this addressing strategy is called classless interdomain routing (CIDR)

		classful addressing : this was old scheme which required subnet address to be 8, 16, 24 bit only ie class A, B, C.
		this was very ineffective since it either provided too few address to subnet or too many wasting most of them.

		255.255.255.255 is used for broadcast, packets with this destination address will be forwarded to all interfaces.

		//DHCP : dynamic host configuration protocol.
			DHCP can be configured so that a host gets same IP every time, or temp IP every time he connects to internet. DHCP also allows host to learn subnet mask, first-hop router address(default gateway), local dns server.
			its also called plug and play protocol.

			its client server protocol, newly connected host is client. each subnet may have DHCP server or a relay agent (router) that knows address of DHCP server.

			steps :
				server discovery : it broadcast a DHCP discover msg with source address 0.0.0.0
				server offer : server broadcast its offer with ip address for the host, its having some time lease.
				DHCP request : client on recieving the offer will reply back with the configuration details sent by server.
				DHCP ACK : server sends ACK confirming the parameters.
		//NAT :
			NAT enabled router looks like single host to outside world. all outgoing and incoming packets from outside have ip of NAT router which circulate it inside the sub network.

			it maintains a NAT table. whenever packet is going outside, its source address is changed to that of NAT router, port is changed by NAT to some available port and entry is added to  NAT table with original ip and port against new port and destination ip.
			when response comes NAT does lookup for that destination ip and port and gets original ip and port, forwards packet to that.

		//ICMP : Internet Control message protocol.
			used for error reporting, it lies just above IP.
			ICMP contains first 8 bytes of datagram which caused that ICMP message.

			source quence message was used for congestion control by sending source quence ICMP to source for it to slow down but its not used now, instead transport layer function is used for congestion control.

			//Traceroute program :
				its used to trace route between source and destination.
				its implemented with ICMP messages. it sends UDP messages to destination with TTL value starting from 1 to n with a wrong port no. the packets are lost from routers according to TTL value, so 1st, 2ndt...nth router are discovered. when router discards the packet it sends ICMP warning to source, due to this source gets to know about that router. source stops sending messages when the packet loss due to TTL stops and some packet reaches destination and sends back port unreachable ICMP message. (because it uses some random port in that message so that when destinatino recieves it, it should give some error)

		//IPv6 : uses 128bit addressing. in addition to unicast and multicast it also support anycast address i.e. any one of the available host can recieve message.

		it has flow labeling and priority i.e. different treatment can be given to diff packets.

		fragmentation/asselbly of packets is done at source/destination only, routers are not allowed to fragment. if the packet size is too big, it simply discards packet and sends ICMP error msg to source.

		header checksum is removed.

		to shift from ipv4 to ipv6 tunneling maybe used. i.e. on the interface that doenst support ipv6 protocols, its encapsulated into ipv4 packet and sent. 

//Routing Algorithms :
	global algorithms which have info of every node is network,  called link state algorithms.

	decentralized algorithms : which dont have information about the whole network and starts with each node having knowledge of its neighbours only.

	static routing algorithms : path does not change often.
	dynamic routing algorithms : path can change at anytimme.

	load-sensitive algorithms : cost of link vary according to congestion.
	load-insensitive algorithms : cost of link does not vary according to congestion.

	todays algorithms are load-insensitive.

	1. Link state algorithm :
		it requires each node to know network topology its achieved by each node broadcast the link state packet which contains information about attached links.

		//Dijkstra algorithm :
			same as standard Dijkstra algorithm, takes O(n^2 ) time which can be reduced by using heap for finding the min.
	2. Distance Vector algorithm :
		asynchronous, distributed.
		each node maintains a distance vector i.e. vector of distances of other nodes from it.
		it also maintains copy of distances vector of its neighbours.
		periodically nodes send thier distance vector to neighbours then neighbours use bellman ford algorithm to update thier distance vector table. if its distance vector is changed it will forward it to neighbours.

		//This algorithm is vulnerable to problem of count till infinity i.e. when two nodes think that its shortest path passes through other they keep bouncing the packet in between. to solve this issue poisoned reverse method is used. but it can only solve problem of looping for two nodes, not more than 3 nodes.

		poisoned reverse method says that : if shortest path from x to z passes through node y then x will tell y that its distance to z is inf (so that y does not use x as intermediate point)

		Autonomous systems : it contains group of routers under same administration. routers within same AS operate same routing algorithm. its called intra-AS routing protocol.to connect AS to each other some of routers act as gateway routers.

		Intra-AS protocols : interior gateway protocols.

			//RIP : routing information protocol.
				its Distance Vector protocol.
				maximum cost is 15. so its limited to AS whoes diamter is 15. 
				in RIP routing info is shared between router every 30 sec using RIP response message (RIP advertisements.)
				each router maintains routing table, which includes forwarding table and distance vector. after each 30 sec router recieves advertisement from neighbours and so it updates its routing table, if it doesnt hear from some neighbour for 180 sec, then its considered that neighbour died, so it updates table and notifies others about this.

				alternative to RIP is HELLO protocol which uses time instead of distance for optimal routing


			//OSPF : open shortest path first.
				(similar algorithm is IS-IS)
				mostly its used in upper-tier ISPs while RIP is used in lower-tier ISPs
				its linked state protocol and uses flooding of link state info and Dijkstra algorithm.
				every router maintains complete topology of network and uses Dijkstra locally to get shortest path tree. the weight of links can be set to anything as we like e.g. 1, inverse of capacity etc.
				router broadcasts routing info to everyone not just neighbours. whenever there's change in link's state it broadcasts link state info.

				using OSPF the AS can be divided into several regions (following hierarchical routing) where each area has its border router. A backbone router is used to connect all such border routers

		Inter-AS protocols : Border Gateway protocol.
			BGP4 or BGP 
			it allows each subnet to advertise its existence to rest of internet without it subnets would be isolated.

			routers from different AS are connected by TCP connection, such routers are called BGP peers.
			the TCP connection and messages sent are called BGP session, there can be external BGP (eBGP) session between routers across AS and internal BGP session (iBGP) between routers within AS.

			BGP allows AS to learn which destinations are reachable via its neighbour AS.
			destinations are not hosts but subnets. 

			two gateway router learn about subnets reachable in other AS by exchanging info with its gateway router using eBGP. then it shares this info within the AS by using iBGP.

//Broadcast protocols :
	//N-way unicast (source duplication) : if packet is to be sent to N nodes, its N copies are made each having diff destination and are sent. but it wastes bandwidth, its complicated to know address of all destinations

	//Uncontrolled flooding : send one copy to each neighbour, which will further forward copies to their neighbours except the one from which it came. but if graph contains cycle then packet may keep cycling in the network.
	also when a node is connected to two or more nodes (having cycle) it will go on creating multiple copies of packet on each iteration, so creating broadcast storm

	//Controlled flooding :
		1. Sequence no Controlled flooding : broadcast packet contains a sequence no, each node contains list of sequence no it has already forwarded so that it never forwards tha packet again.
		2. Reverse path forwarding : (RP Broadcasting) A node will forward the packet only when it has recieved the packet from the node which is present on the shortest path from current node to source of packet.

	//Spanning Tree Broadcast :
		forward the packet on only those edges which are part of spanning tree.
		method to construct spanning tree is center based approach.
		a center node (rendezvous point or core ) is defined. all nodes send tree-join message towards center, when the message reach center or any node connected to center, new edge is added into ST.

//MultiCast:
	to deliver msg to specific people only, their group is created called as multicast group. to form and maintain group IGMP is used.

	Class D ip addresses are reserved for Multicast groups.

	//Internet Group Management Protocol.
		IGMP provides the host method to inform router that the host wants to join specific group, scope of IGMP is only till host and its first router.

		so to route packets between these multicast routers we need another mechanism i.e. multicast routing algorithm.

		IGMP provides 3 messages i.e. membership_query message that the router sends to its interface to know which hosts are part of which multicast group, on recieving membership_query, hosts send membership_report. host can also send membership_report first without getting any membership_query if he wants to join before. third type of message is leave Group.

		soft state protocols are the ones in which a state is removed due to timeout if its not refreshed after some interval.
		in IGMP even if host dont send leave message, it can be removed from group, if it doest reply to the membership_query message.

//Multicast routing algorithm :
	1. using group-shared tree :
		the tree can be constructed using center based approach. and then packets can be forwarded on it.
	2. using source-based tree :
		construct a tree for each source. RPF algorithm is used to construct the tree for each source vertex.

		if there are routers in tree which do not wish to recieve messages will send prune message to its upstream router so that upstream router wont send packets to this router.

	//Protocol independent Multicast (PIM) router protocol :
		it has two conditions dense mode and sparse mode.

		in dense mode it uses source-based tree approach with RPF  with prune.
		sparse mode uses center based tree approach.

//ARP : address resolution protocol :
	used to associate ip address to physical address. its used by host or router to know physical address of machine whne ip is known. it sends ARP query with IP address.

//RARP : it allows host to know ip address if it only knows its physical addressb