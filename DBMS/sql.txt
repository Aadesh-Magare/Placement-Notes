
select branch_name from loan //by default duplicates aren't removed 
select distinct branch_name from loan //to remove duplicates
select all branch_name from loan //	explicitly tell that don't remove duplicates
select amount * 100 from loan //support arithmatics

//where used for conditions, this condition is checked for each tuple there's a keyword having, which is also used for conditions but those conditions are evaluated for groups which are formed using the groupby keyword.
//where also suppports and, or , not operators along with between, not between.
select loan_number from loan where branch_name = "perry" and amount > 1000 

//from does cartesian product of its arguments, so most of times you take natural join of it, using the where condition.
select distinct customer_name, borrower.loan_number from borrower, loan where borrower.loan_number = loan.loan_number

//its called cross join, from does cross join implicitly when we give two columns seperated by comma.
	select * from table1 cross join table2 
		its equivalnet to 
	select * from table1, table2


//as is used to rename 
select distinct customer_name, borrower.loan_number as load_id from borrower, loan where borrower.loan_number = loan.loan_number and branch_name = "perry"
//tuple variables
select distinct customer_name, T.loan_number from borrower as T, loan as S where T.loan_number = S.loan_number

//like used for string matching % = any substring 	_ = any character
select customer_name from customer where customer_street like "%Main%"
//for escape characters in string use keyword escape
like "ab\%cd%" escape "\" it matches all string beginning with "ab%cd"

//order by used to sort the results
select distinct customer_name from borrower, loan where borrower.loan_number = loan.loan_number and brach_name = "perry" order by customer_name
//you can order by multiple parameters in case of tie. for descending order use desc keyword.
order by amount desc

//set operations union, intersect and except automatically eliminates duplicates to retain duplicates use all keyword e.g. A union all B

//avg and sum works on strings only
//groupby attribute makes groups based on values of attribute.
select branch_name, avg(balance) from account groupby branch_name
//duplicates are allowed by default use distinct to remove them. 
//conditions in having keyword are applied after forming groups
//count(*) counts every tuple, distinct is not allowed with count(*)

//if where and having are in same query then where is done first and result is groupby and then the groups are checked against the having condition.

//arithmatic with null results in null
select loan_number from loan where amount is null
//comparison with null mostly results in false or unknown
//all aggregate functions excpet count(*) ignore null
//count of empty relation results into 0, while other functions give null on empty relations.

//in , not in to check set membership
selct distinct customer_name from borrower where customer_name in (select customer_name from depositor)
selct distinct customer_name from borrower where customer_name not in ("cust1", "cust2")

//greater than at least one in sql is > some
select branch_name from branch where assets > some (select assets from branch where branch_city = "Brook")
// "=some" is same as "in" where as "<> some" is not same as "not in"
//keyword "any" and "some" are same
// greater than all in sql is > all 
// "<> all" is same as "not in" 

//aggregate functions cant be composed
max(avg(balance)) not allowed

//exists returns true if subquery is nonempty.
//not exists can be used to check for set containment i.e. to check if one set is subset of other.
select distinct S.customer_name from depositor as S where not exists ((select branch_name from branch where branch_city= "brook") except (select R.branch_name from depositor as T, account as R where T.account_number = R.account_number and S.customer_name = T.customer_name))
//in case of subquery scoping rules apply to tuple variables. in subquery you can use tuple varialbes defined in it or its superquery. 
//subquery cant have order by clause


//unique construct can be used to test for duplicates.
//not unique returns true if there are duplicates
//unique checks for exact similarity i.e. if two tuples are same but one of the fileds in either are null then they are treated as distinct.

//we can have subquery in the from clause but the result of subquery must have a name i.e. u must rename it using as clause.
select branch_name, avg-balance from (select branch_name, avg(balance) from depositor groupby branch_name as result(branch_name, avg-balance)) where avg-balance > 1200

//DELETE finds all branches at perry and then delete corrsponding account tuples
delete from accout where branch_name in (select branch_name from branch where branch_city ="perry")
//we can use same relation in delete from and the inner select
delete from account where balance < (select avg(balance) from account)
//here it first checks each tuple in account, if the balance is less than avg at the bank, then all those tuples are deleted. here performing all test before deleting is imp since if we start deleting one by one the avg will change.

//to insert values the tuple must be of correct arity and it must be in domain.
insert into account select branch_name, loan_number, 200 from loan where branch_name = "perry"
//we can specify the order of attributes
insert into account(branch_name, balance) values("perry", 1200)
insert into account(balance, branch_name) values(1200, "perry")
//select is evaluated completely before inserting anything.

//use update to update a value in tuple instead of entire tuple
update account set balance = balance * 1.05 where balance > select avg(balance) from account
//first all tuples are checked for conditon and then all eligible are updated 

//VIEW : 

create view all-customer as (select branch_name, customer_name from depositor, account where depositor.account_number = account.account_number) union (select branch_name, customer_name from borrower, loan where borrower.loan_number = loan.loan_number)
//once created a view can be used anywhere, where a relation can be used.
select customer_name from all-customer where branch_name = "perry"
//the views are saved in database so, until you drop them, they are there.

create view branch-loan as select branch_name, loan_number from loan. 
//a veiw can be used anywhere , where a relation can be used so
insert into branch-loan values ("pery", "L-230") is valid.
//but the values will be inserted actually into relation loan as ("perry", "L-230", null)
//so view update becomes difficult when more than one relation is involved. hence the rule is applied that modification through view is possible only when its concerned with only one relation.

//inner join, outer join and natural join
loan inner join borrower on loan.loan_number = borrower.loan_number
//here you pass in the join condition which is checked for join. the result contains columns from both relations loan and borrower so the common columns appear twice.
//as clause can be used to rename the result of this
loan left outer join borrower on loan.loan_number = borrower.loan_number
//same working as that of above but the results contains extra terms from left relation which aren't //even common, thier unknown fileds are null
loan natural inner join borrower 
//here no need to mention the condition with on clause(sice we used natural), it checks which columns are common and peroforms join on that. result doesnt contain repeated columns


//join types are :
				inner join
				left outer join
				right outer join
				full outer join
//join conditions are
				natural
				on (predicate)
				using (A1, A2, A3, ...)

//keywords inner and outer are optional since it can be deduced from remaining query.
//ordering of attributes in case of natural join is
commmon attributes (in same order as that of left relation) -> uncoomon from left relation -> uncommon from right relation. 
//using is similar to natural, instead of checking all common attributes only those are checked which are passed to using. attributes passed to using must be common to both relations. results does not contain duplicate columns

//sql allows concept like typdef in c
create domain person-name char(20)
//now you can use person-name to define type of attribute, just like built in types.

//while creating a schema 
create table customer( customer_name char(20) not null,
						customer_city char(30),
						assets interger,
						primary key(customer_name), 
						check(assets >= 0))
check forces a condition that must be satisfied by every tuple

//to add an attribute to existing table
alter table r add A D
alter table r drop A						

//case in sql

case
	when pred1 then result1
	when pred2 then result2
	when pred3 then result3
	else result0
end

//retuns first non null A from the list, if all are null then it returns null
coalesce(A1, A2, A3, A4) 		

//nth max salary from table

SELECT Salary FROM Employee 
ORDER BY Salary DESC LIMIT n-1,1

The LIMIT clause takes two arguments in that query â€“ the first argument specifies the offset of the first row to return, and the second specifies the maximum number of rows to return

//Stored procedures :
	sql statements stored in the database system, users can call with some parameters its like library functions.

//Triggers :
	its also stored sql statements, but we cant call it, its implicitly invoked by database system when certain even has happened.

	Triggers which contains dbms modification code (insert, update) are called nested triggers.

//Cursors : 
	database objects which are used by applications to manipulate data in set by row-by-row basis.

//Primary key vs Unique key :
	both enforce unique values onto the column. but primary key creates clustered index while unique key creates non clustered index. primary key doesn't allow nulls while unique key allows.

//Truncate vs delete :
	Truncate will delete everything all rows (but structure of table remains) it deallocates pages of the table. doest create log so cant undo it.

	delete will remove one row at time, writes log so it can be undo.