atomicity and durability is maitained by recovery management component.

//Shadow-copy method :

	based on creating new copy of database and maintaining a db pointer on disk. the pointer is updated only when the transaction is commited. all changes are made to the copy of database until the pointer is updated to point to the new database.

	the motivation for concurrency in database is same as the motivation for multiprogramming in the os.

	the order of execution of instructions in transactions are called schedules.
	serial schedule means one followed by other completely e.g.
	T1 -- T2 (T2 after T1 has finished, not concurrent)

//Serializability:

two instructions I1 and  I2 are conflicting only if they are from diff transactions and one of them is write.

if a schedule S can be transformed into S' by series of swaps of non-conflicting instructions, we say that they are conflict equivalent.

a schedule is called conflict serializable if it is conflict equivalent to a  serial schedule

Its possible to have two schedules that produce same output but they are not conflict equivalent

// View serializability

two schedules are view equivalent if :

1. for data Q,  if T1 reads initial value of Q in S then T1 must read initial value of Q 	in S'
2. if T1 reads value of Q in S that was produced by Ti then  T1 must read the value of Q 	produced by Ti in S' also
3. if for Q, T1 performs final write in S, then T1 must perform final write in S'

a schedule is vew serializabale if it is view equivalent to serial schedule

Every conflict serializabale schedule is view serializabale but converse is not true

Blind write means writing value without reading it (without knowing what maybe the current value).

Blind write appear in any view serializabale schedule that is not conflict serializabale

//Recoverability
certain schedules are non recoverable.
recoverable schedule is where for every pair of Ti, Tj such that Tj reads data written by Ti, commit of Ti appears before commit of Tj

when single transaction failure cause a series of rollbacks, its called cascading rollback

cascadeless schedule is the one where, for each Ti and Tj, if Tj reads data written by Ti then commit of Ti appears before read of Tj

Every cascadeless schedule is recoverable

//Testing for serializability.

test for conflict serializability.

construct a directed graph G(V,E) with vertices V = all transactions E = edges Ti --> Tj if
1. Ti does write(Q) before Tj does read(Q)
2. Ti does read(Q) before Tj does write(Q)
3. Ti does write(Q) before Tj does write(Q)
if the graph contains cycle then its not conflict serializable else it is.
the serializability order can be obtained by topological sorting.

test for view serializability is NP-complete problem, here you need to modify the graph, i.e. conditions to include a edge are different. then if the resultant graph contains no cycle, then schedule is view serializable, if it contains cycyle then we cant say anything, it still can be view serializable.

//study test for view serializability in details later.