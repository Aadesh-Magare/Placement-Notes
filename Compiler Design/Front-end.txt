// Lexical Analyser :

    Only phase which reads actual program character by character, only this phase knows about the line numbers where each token appears.

    Main tasks of the phase :
        1. Convert lexems into tokens.
        2. Removing comments and whitespace.

// Syntax Analyser : takes grammar and tokens as input.

    Yeild of parse tree is nothing but output of parse tree, to get the yeild we can traverse the tree top to bottom, left to right
    
    // Ambiguous-Unambiguous grammar :
        If grammar generates more than one parse trees or LMD or RMD for a string then the grammar is ambiguous.
        Most parsers don't allow ambiguous grammars so we have to convert it to unambiguous.

        There is no algorithm to detect whether the grammar is ambiguous or not, also there is no algorithm to convert ambiguous grammar to unambiguous.

        // Removing ambiguity of grammar :
            
            Should take care of associativity and precedence in case of arithmatic grammars.
            
            A left-recursive grammar will make sure that left associativity is followed while right recursive will make sure right associativity is followed.
                LR : A -> Aa | b
                RR : E -> aE | c
                
            The operator at lower level in parse tree will be evaluated first, so higher precedence operator Should come at lower level in parse tree (away from start symbol) than lower precedence operator.

    // Left-Recursive / Right-Recursive :

        Some parsers don't work well Left recursive grammar.
            e.g.    A -> Ab | c
            A is calling A, before doing anything else, this can lead to infinite loop. Hence we need to convert left recursive grammar to right recursive without affecting the language generated by it.
        
        // Removing Left Recursion:
            if grammar is A -> A alpha | beta
            equivalent RL grammar is :
                                        A  -> beta A'
                                        A' -> alpha A' | epsilon 
            
            write given grammar in this format, substitute values for A, alpha, beta and use the formula to get right-recursive grammar.

    // Deterministic / Non-Deterministic grammar :

        parse tree generation by Non-Deterministic grammar involves back-tracking since out of multiple available option we might choose wrong one initially which results in need of backtracking.

        we can convert such Non-Deterministic grammar to Deterministic by using left-factoring i.e. taking out common part of RHS and creating new production out of the uncommon part.
        e.g. A -> ab1 | ab2 | ab3 here not sure which production to choose on seeing a.
        equivalent deterministic grammar:
                A  -> aA'
                A' -> b1 | b2 | b3 
        
        left-factoring postpones the descision making in choosing the production till we see a symbol that is not common across conflicting productions.

    
    Removing Non-Determinism from the grammar will not remove the ambiguity.

    // Types of parsers :
        None of the parsers would work with ambiguous grammar except the operator precedence parser.

        // Top Down Parsers (TDP) : 
            here main descision is which production to choose at every stage of constructing parse tree. The parse tree is built in left-most derivation fashion.
            // TDP with full backtracking
                Bruteforce method
            // TDP without full backtracking : No Left-Recursion, No Non-Determinism
                Recursive descent : Does not need extra stack, uses OS stack directly.
                    write an actual program (C language mostly) for the grammar.
                    1. one function for each variable in productions.
                    2. match function that will match the current input with given character.
                    3. main function that will call function corresponding to initial variable and check the end of input string after return from initial call.
                Non-Recursive descent LL(1) :
                    LL(1) : Left to right, Left-most derivation, look ahead of 1 symbol.
                    // First() :
                        First of a variable is the first of its RHS from production i.e. the terminal symbol. It can include epsilon as well.
                    // Follow() :
                        Follow of a symbol is first of the group that follows it in the production RHS.
                        for right-most symbol its follow is follow of LHS. also for some variable everything on its right can become epsilon then its follow will include follow of LHS.
                    // Parsing table :
                        LL(1) parser cannot be used for all grammars, for some grammars we might get multiple entries in one cell of parse table those grammars won't work with LL(1) parser.

                        Rows are variables from productions and columns are terminals along with $. we have to write all productions into the cells of this table.

                        Now each production will go into the row of that symbol on its LHS. The cell in row will be decided as follows :
                            1. if the RHS contains some variables/terminals : find first() of the LHS, the production goes into the results cell.
                            2. if RHS is epsilon only : find Follow() of the LHS, the production goes into the results cell.
                             
        // Bottom Up Parsers (BUP) : 
            here main descision is when to reduce a terminal into variable. The parse tree is build in reverse order of right-most derivation. (bottom-up)
            // Operator precedence parser : can work with ambiguous grammar as well.
                // Operator grammar : grammar in which no two variable are adjacent.
                // Operator relation table :
                    rows as well as columns are terminals (operators)
                    basically we are comparing precedence of operators against each other.
                    e.g.    grammar is :
                                E ->  E + E | E * E | id 
                            Operator relation table is :
                                id      +       *       $
                            id  -       >       >       >
                            +   <       >       <       >
                            *   <       >       >       >
                            $   <       <       <       -
                // Generating parse tree:
                    A stack is used which initially contains $, the input string ending with $ is compared against the contents of stack.

                    if item is stack has less precedence than input symbol : push the symbol onto stack.
                    if item in stack has more precedence than input symbol : pop the symbol from stack and reduce it using its production.

                    following the procedure we get a parse tree in bottom-up fashion.

                // Operator relation table takes n^2 size for n operators hence to save space operator function table is used that takes 2n size for n operators. when using operator function table additional error handling needs to be done since this table will have entries for even those comparisons which are not present in operator relation table so a separate data structure should be used to remember such cases.

            // LR parsers:
                LR(0)
                SLR(1)
                LALR(1)
                CLR(1)

    


