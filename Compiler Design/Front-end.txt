// Lexical Analyser :

    Only phase which reads actual program character by character, only this phase knows about the line numbers where each token appears.

    Main tasks of the phase :
        1. Convert lexems into tokens.
        2. Removing comments and whitespace.

// Syntax Analyser : takes grammar and tokens as input.

    Yeild of parse tree is nothing but output of parse tree, to get the yeild we can traverse the tree top to bottom, left to right
    
    // Ambiguous-Unambiguous grammar :
        If grammar generates more than one parse trees or LMD or RMD for a string then the grammar is ambiguous.
        Most parsers don't allow ambiguous grammars so we have to convert it to unambiguous.

        There is no algorithm to detect whether the grammar is ambiguous or not, also there is no algorithm to convert ambiguous grammar to unambiguous.

        // Removing ambiguity of grammar :
            
            Should take care of associativity and precedence in case of arithmatic grammars.
            
            A left-recursive grammar will make sure that left associativity is followed while right recursive will make sure right associativity is followed.
                LR : A -> Aa | b
                RR : E -> aE | c
                
            The operator at lower level in parse tree will be evaluated first, so higher precedence operator Should come at lower level in parse tree (away from start symbol) than lower precedence operator.

    // Left-Recursive / Right-Recursive :

        Some parsers don't work well Left recursive grammar.
            e.g.    A -> Ab | c
            A is calling A, before doing anything else, this can lead to infinite loop. Hence we need to convert left recursive grammar to right recursive without affecting the language generated by it.
        
        // Removing Left Recursion:
            if grammar is A -> A alpha | beta
            equivalent RL grammar is :
                                        A  -> beta A'
                                        A' -> alpha A' | epsilon 
            
            write given grammar in this format, substitute values for A, alpha, beta and use the formula to get right-recursive grammar.

    // Deterministic / Non-Deterministic grammar :

        parse tree generation by Non-Deterministic grammar involves back-tracking since out of multiple available option we might choose wrong one initially which results in need of backtracking.

        we can convert such Non-Deterministic grammar to Deterministic by using left-factoring i.e. taking out common part of RHS and creating new production out of the uncommon part.
        e.g. A -> ab1 | ab2 | ab3 here not sure which production to choose on seeing a.
        equivalent deterministic grammar:
                A  -> aA'
                A' -> b1 | b2 | b3 
        
        left-factoring postpones the descision making in choosing the production till we see a symbol that is not common across conflicting productions.

    
    Removing Non-Determinism from the grammar will not remove the ambiguity.

    // Types of parsers :
        None of the parsers would work with ambiguous grammar except the operator precedence parser.

        // Top Down Parsers (TDP) : 
        here main descision is which production to choose at every stage of constructing parse tree. The parse tree is built in left-most derivation fashion.
            // TDP with full backtracking
                Bruteforce method
            // TDP without full backtracking : No Left-Recursion, No Non-Determinism
                Recursive descent
                Non-Recursive descent LL(1) :
                    LL(1) : Left to right, Left-most derivation, look ahead of 1 symbol.
                    // First() :
                        First of a variable is the first of its RHS from production i.e. the terminal symbol. It can include epsilon as well.
                    // Follow() :
                        Follow of a symbol is first of the group that follows it in the production RHS.
                        for right-most symbol its follow is follow of LHS. also for some variable everything on its right can become epsilon then its follow will include follow of LHS.

        // Bottom Up Parsers (BUP) : 
        here main descision is when to reduce a terminal into variable. The parse tree is build in reverse order of right-most derivation. (bottom-up)
            // Operator precedence parser : can work with ambiguous grammar as well.
            // LR parsers:
                LR(0)
                SLR(1)
                LALR(1)
                CLR(1)

    


